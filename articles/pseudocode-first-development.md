---
title: "PRを小さく分割するなら、レイヤーごとではなくステップごとに"
emoji: "🪜"
type: "tech"
topics: ["アジャイル", "コードレビュー", "チーム開発", "疑似コードプログラミング"]
published: true
---

## 🤔 PRを小さくしているのに、なぜ手戻りが起きるのか

PRを小さく分割するのは良いプラクティスです。レビューしやすいし、コンフリクトも起きにくい。

でも、PRを小さくしているのに、完成が近づいたタイミングで手戻りが起きた経験はないでしょうか。

- 「この想定、抜けてない？」
- 「全体組み合わせると、この設計じゃない方がよくない？」
- 「これだと要件満たせなくない？」

個々のPRは問題なくLGTMだったはずなのに。原因はPRの「切り方」にあります。

## 🪤 レイヤー単位のPR分割の罠

ここではWeb APIの実装を例に考えてみます。1つのAPIを実装するとき、PRを小さくしようとしてレイヤーで分割しがちです。

```
PR1: ドメイン層の実装
PR2: リポジトリ層の実装
PR3: ユースケース層の実装
```

各PRは単体で見ると正しく見えます。型は合っているし、テストも通る。LGTMです。

問題は、最後のユースケース層で全体を組み合わせたときに起きます。

- エンティティに必要な振る舞いが足りない
- リポジトリに必要なメソッドが足りない
- 層をまたぐ処理の考慮が漏れている

各レイヤーのPRだけでは「全体を通して処理を見る」視点になりにくく、ユースケース層のPRで初めてその視点が生まれます。もっと早い段階で気づけたはずの指摘が、そこまで出てきません。

また裏を返せば、何回もPRを出しているのに仕様の抜け漏れに気づけるのはその1回だけということです。PRを小さくして個々の実装はレビューしやすくなっていますが、仕様の抜け漏れを防ぎやすくなっているわけではありません。

## 💡 疑似コードで「縦の文脈」を先に作る

私は、**疑似コードで全体の処理フローをコメントで先に書く**ことでこの問題に対処しています。

1. まず疑似コードで全体の処理フローをコメントで書く
2. **この空実装の時点で最初のPRを出す**
3. フィードバックを反映する
4. コメントを1ステップずつ実装してPRを出す

ポイントは、まだ1行も実装していない段階で設計レビューが入ることです。「このケース漏れてない？」「この順番でいいの？」というフィードバックが最速で来ます。そしてこの時点の手戻りコストはほぼゼロです。コメントを書き直すだけですから。

## 📦 具体例：注文作成APIの場合

「注文を作成するAPI」を実装する場面で、疑似コードを起点にしたPRの進め方を見てみます。

### PR1：疑似コードで全体の処理フローを書く（空実装）

```go
func (uc *CreateOrderUseCase) Execute(ctx context.Context, input CreateOrderInput) error {
    // 1. 在庫を取得する

    // 2. 在庫が足りるか確認する
    //    - 注文数が在庫数を超えていたらエラー

    // 3. 注文を作成する
    //    - 商品情報から合計金額を計算
    //    - 合計金額が上限（100万円）を超えていたらエラー
    //    - 注文エンティティを生成

    // 4. 在庫を引き当てる
    //    - 各商品の在庫を注文数分だけ減らす

    // 5. 注文を保存する

    // 6. 注文完了通知を送る
    //    - メールで注文確認を送信

    return nil
}
```

**このPRで設計レビューが入ります。** まだ1行も実装していませんが、レビュアーはこの時点で全体の流れを把握できます。

- 「在庫の引き当てと注文の保存、トランザクションで囲む必要あるよね」
- 「通知の送信は非同期でよくない？」
- 「在庫不足のとき、どの商品が足りないか返した方がよくない？」

こうしたフィードバックが、実装前に来ます。

### PR2：Step 1「在庫を取得する」を実装

```go
// usecase.go
func (uc *CreateOrderUseCase) Execute(ctx context.Context, input CreateOrderInput) error {
    // 1. 在庫を取得する
    stock, err := uc.stockRepo.GetByProductID(ctx, input.ProductID)
    if err != nil {
        return err
    }

    // 2. 在庫が足りるか確認する
    //    - 注文数が在庫数を超えていたらエラー

    // 3. 注文を作成する
    //    - 商品情報から合計金額を計算
    //    - 合計金額が上限（100万円）を超えていたらエラー
    //    - 注文エンティティを生成

    // 4. 在庫を引き当てる
    //    - 各商品の在庫を注文数分だけ減らす

    // 5. 注文を保存する

    // 6. 注文完了通知を送る（非同期）
    //    - メールで注文確認を送信

    return nil
}
```

```go
// entity.go
type Stock struct {
    ID        string
    ProductID string
    Quantity  int
}
```

```go
// repository.go
func (r *stockRepository) GetByProductID(ctx context.Context, productID string) (*Stock, error) {
    row := r.db.QueryRowContext(ctx,
        "SELECT id, product_id, quantity FROM stocks WHERE product_id = $1", productID,
    )
    var s Stock
    if err := row.Scan(&s.ID, &s.ProductID, &s.Quantity); err != nil {
        return nil, err
    }
    return &s, nil
}
```

このPRでは、ユースケース層のStep 1を埋めると同時に、そこで必要になるStockエンティティとStockRepositoryの`GetByProductID`を実装します。重要なのは、**PRの中に「利用者側」のコードが含まれている**ことです。レビュアーは、作ったパーツがどう使われるかをPR内で確認できます。

### PR3：Step 2「在庫が足りるか確認する」を実装

```go
// usecase.go
func (uc *CreateOrderUseCase) Execute(ctx context.Context, input CreateOrderInput) error {
    // 1. 在庫を取得する
    stock, err := uc.stockRepo.GetByProductID(ctx, input.ProductID)
    if err != nil {
        return err
    }

    // 2. 在庫が足りるか確認する
    if err := stock.EnsureAvailable(input.Quantity); err != nil {
        return err
    }

    // 3. 注文を作成する
    //    - 商品情報から合計金額を計算
    //    - 合計金額が上限（100万円）を超えていたらエラー
    //    - 注文エンティティを生成

    // 4. 在庫を引き当てる
    //    - 各商品の在庫を注文数分だけ減らす

    // 5. 注文を保存する

    // 6. 注文完了通知を送る（非同期）
    //    - メールで注文確認を送信

    return nil
}
```

```go
// entity.go
func (s *Stock) EnsureAvailable(quantity int) error {
    if s.Quantity < quantity {
        return errors.New("insufficient stock")
    }
    return nil
}
```

このPRでは、Stockエンティティに`EnsureAvailable`という振る舞いを追加し、ユースケース層のStep 2を埋めます。

### PR4以降：Step 3, 4, ... を順に実装

同じように、疑似コードのステップを1つずつ実装してPRを出していきます。毎回、残りの疑似コードが全体の文脈を伝えてくれます。

## ✅ この進め方のメリット

### 毎PRで全体の流れを確認できる

レイヤー切りだと、リポジトリ層のPRにはリポジトリしかありません。それがどう使われるかは、後のPRを見るまでわかりません。

疑似コード起点だと、実装したパーツがどう呼ばれるかが同じPR内で見え、残りの疑似コードが全体の文脈を伝えてくれます。レビュアーは毎回全体像に触れることになるので、仕様漏れや設計不備が早期に見つかります。

### チーム内に要件の理解が広がる

PRごとにレビュアーが違えば、そのたびに別のメンバーが機能の全体像に触れることになります。結果として、誰が何を作ろうとしているのか、その機能がどんな要件を満たそうとしているのかが、チーム内に自然と伝わっていきます。

## 🙏 レビュアーへのお願い

せっかく疑似コードで全体の流れを書いても、レビュアーが変更差分だけ見ていたら意味がありません。

PRの差分だけでなく、少し上下に広げて、疑似コードで書かれた全体の流れを確認してください。「この実装が全体のどこに位置するか」を都度確認することで、この手法が活きます。

## 📝 まとめ

- PRはレイヤーで横に切るのではなく、疑似コードのステップごとに縦に切る
- 最初の空実装PRが、最速のフィードバックループを作る

疑似コードを先に書いて、実装前にレビューを受ける。たったこれだけのことですが、手戻りのコストは大きく変わります。
